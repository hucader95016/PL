# include <stdio.h>
# include <string>
# include <iostream>
# include <stdlib.h>
# include <vector>
# include <stack>
# include <sstream>
# include <map>
# include <iomanip>

using namespace std ;

enum TokenType {
  INT, STRING, DOT, FLOAT, NIL,
  T, QUOTE, SYMBOL, LEFT_PAREN, RIGHT_PAREN,
  PRIMITIVE
};

enum NonTerminal {
  ATOM, SEXP
};

struct Token {
  int tokenType ;
  string lexeme ;   
  int line ;
  int column ;
} ; 

struct TokenTreeNode {
  Token token ;  
  bool internal ;
  TokenTreeNode *left ;
  TokenTreeNode *right ;
} ; 

typedef TokenTreeNode *TokenTreeNodePtr ; // use to build token tree 

void PreOrder( TokenTreeNodePtr head ) {
  if ( head == NULL ) {
    ; // cout << "null\n" ;
  } // if

  else {
    if ( head -> internal ) 
      cout << "internal\n" ;
    else
      cout << head -> token.lexeme << endl ;

    PreOrder( head -> left ) ;
    PreOrder( head -> right ) ;
  } // else
} // PreOrder()

class TokenTree {
  private :
  TokenTreeNodePtr mHead ;
  int mParentheseCount ;
  void HandleQuoteTree( TokenTreeNodePtr &walk, Token quote ) ;

  public :
  void BuildTokenTree( vector<Token> tokenList ) ;
  
  TokenTreeNodePtr GetTokenTree() {
    return mHead ;
  } // GetTokenTree()

  void Reset() {
    mHead = NULL ;
    mParentheseCount = 0 ;
  } // Reset()

  void SetParenCount( int num ) {
    mParentheseCount = num ;
  } // SetParenCount()

  void SetTokenTreeHead( TokenTreeNodePtr newHead ) {
    mHead = newHead ;
  } // SetTokenTreeHead()
} ;

class ErrorType {
  public : 
  int mLine ;
  int mColumn ;
  bool mEof ;
  bool mSkip ;
  string mMessage ;
  TokenTreeNodePtr mTokenTree ;

  ErrorType() {
    mEof = false ;
    mMessage = "" ;
    mTokenTree = NULL ;
    mSkip = false ;
  } // ErrorType()
};

class DefineTable {
  private :
  map<string,TokenTreeNodePtr> mDefineTable ;
  vector<string> mPrimitive ;

  public :
  DefineTable() { // constructor 
    string temp[100] = { "cons", "list", "quote", "define", "car", "cdr", "atom?", "pair?",
                         "list?", "null?", "integer?", "real?", "number?",
                         "string?", "boolean?", "symbol?", "+", "-", "*", "/", // in OurSchem,real? = number?
                         "not", "and", "or", ">", "<", ">=", "<=", "=", "string-append",
                         "string>?", "string<?", "string=?", "eqv?", "equal?", "begin",
                         "if", "cond", "clean-environment", "exit" } ;

    for ( int i = 0 ; i < 100 ; i++ ) {
      if ( temp[i] != "" )
        mPrimitive.push_back( temp[i] ) ;
    } // for

 
    for ( int i = 0 ; i < mPrimitive.size() ; i++ ) {
      TokenTreeNodePtr head ;
      head = new TokenTreeNode ;
      head -> internal = false ;
      head -> left = NULL ;
      head -> right = NULL ;
  
      Token token ;
      token.tokenType = PRIMITIVE ;
      string preprocessStr = "#<procedure " ;
      token.lexeme = preprocessStr + mPrimitive[i] + ">" ;
      // token.lexeme = mPrimitive[i] ;

      head -> token = token ;
      mDefineTable[ mPrimitive[i] ] = head ;
    } // for 
  } // DefineTable()

  void BindingSymbol( string symbol, TokenTreeNodePtr tokenTreeHead ) ;

  TokenTreeNodePtr GetSymbolTree( string symbol ) {
    map<string,TokenTreeNodePtr> :: iterator it ;
    it = mDefineTable.find( symbol ) ;
    if ( it == mDefineTable.end() )
      return NULL ;
    else 
      return it -> second ; 
  } // GetSymbolTree()

  bool IsInternalFunc( Token token, string &sym ) { // sym help decide to do which command 
    string symbol = token.lexeme ;
    if ( token.tokenType == PRIMITIVE ) {
      for ( int i = 0 ; i < mPrimitive.size() ; i++ ) {
        if ( symbol == GetSymbolTree( mPrimitive[i] ) -> token.lexeme ) {
          sym = mPrimitive[i] ;
          return true ;
        } // if
      } // for

      cout << "impossible error IsInternalFunc\n" ;
      return false ;
    } // if

    TokenTreeNodePtr symbolBinding = GetSymbolTree( symbol ) ;
    if ( symbolBinding != NULL ) {
      for ( int i = 0 ; i < mPrimitive.size() ; i++ ) { 
        if ( GetSymbolTree( mPrimitive[i] ) == symbolBinding ) {
          sym = mPrimitive[i] ;
          return true ;
        } // if
      } // for
    } // if

    return false ;
  } // IsInternalFunc()

  void Clean() {
    mDefineTable.clear() ;
    for ( int i = 0 ; i < mPrimitive.size() ; i++ ) {
      TokenTreeNodePtr head ;
      head = new TokenTreeNode ;
      head -> internal = false ;
      head -> left = NULL ;
      head -> right = NULL ;
  
      Token token ;
      token.tokenType = PRIMITIVE ;
      string preprocessStr = "#<procedure " ;
      token.lexeme = preprocessStr + mPrimitive[i] + ">" ;
      // token.lexeme = mPrimitive[i] ;

      head -> token = token ;
      mDefineTable[ mPrimitive[i] ] = head ;
    } // for 
  } // Clean()
};

struct ANodeOfSExp {
  vector<Token> tokenList ;
  TokenTree tokenTree ;
  TokenTreeNodePtr resultTree ;
  ANodeOfSExp *next ;
} ;

typedef ANodeOfSExp *ANodeOfSExpPtr ;
// ----------------------------------------------------------project1
// --------------------------------------------get token start
ANodeOfSExpPtr ReadSExp( bool &isExit ) ; 
Token GetToken() ; // return false if doesn't get token
int DefToken( string lexeme ) ;
void HandleBackslash( string &token ) ;

bool IsWhiteSpace( char ch ) ;
bool IsSeparator( char ch ) ;
bool IsExit( ANodeOfSExpPtr aNodeHead ) ;
bool IsNum( char ch ) ;
bool IsOperator( char ch ) ; // +,-,*,/

void SkipWhiteSpace() ;
void SkipWhiteSpace_special() ;
void Skip_sameLine() ;
void SkipComment() ;
// --------------------------------------------get token end
// --------------------------------------------token tree start
void BuileTree( vector<Token> tokenList ) ;
void PrintSExp( ANodeOfSExpPtr head, TokenTreeNodePtr resultHead ) ;
void PrintTokenTreeRecur( TokenTreeNodePtr head, TokenTreeNodePtr walk, int spaceCount, bool first ) ;
void PrintTokenTree( TokenTreeNodePtr head ) ;
// --------------------------------------------token tree end
// --------------------------------------------syntax analysis start & error check
bool Atom( vector<Token> &tokenList ) ;
bool SExp( vector<Token> &tokenList ) ;
Token PeekToken() ;

void SExpError_type1( ErrorType error_ ) ; // atom or '(' expected
void SExpError_type2( ErrorType error_ ) ; // ')' expected
// --------------------------------------------syntax analysis & error check end
// --------------------------------------------------------------------project2 
// evaluate start
TokenTreeNodePtr EvalExp( TokenTreeNodePtr inTokenTreeHead, bool topFunc ) ;
TokenTreeNodePtr Evaluate( string cmd, TokenTreeNodePtr inHead ) ;

Token FindFirstArg( TokenTreeNodePtr head, bool &topLevel ) ;
bool IsList( TokenTreeNodePtr head ) ;
bool CheckArgNum( string sym, TokenTreeNodePtr inTokenTree ) ;
bool Equal_rec( TokenTreeNodePtr arg1, TokenTreeNodePtr arg2 ) ;
void ReplaceTheSame( string key, TokenTreeNodePtr &head ) ;
// evaluate end
// format check start
bool Define( TokenTreeNodePtr head ) ;
bool Cond( TokenTreeNodePtr head ) ;
// format check end

int gLine = 1 ; 
int gColumn = 1 ;
int gTestNum ;
Token gBufferToken ;
DefineTable gDefineTable ;
TokenTreeNodePtr gNilTokenPtr = new TokenTreeNode, gTTokenPtr = new TokenTreeNode ;

int main() {
  gNilTokenPtr -> left = NULL ;
  gNilTokenPtr -> right = NULL ;
  gNilTokenPtr -> internal = false ;
  gNilTokenPtr -> token.lexeme = "nil" ;
  gNilTokenPtr -> token.tokenType = NIL ;

  gTTokenPtr -> left = NULL ;
  gTTokenPtr -> right = NULL ;
  gTTokenPtr -> internal = false ;
  gTTokenPtr -> token.lexeme = "#t" ;
  gTTokenPtr -> token.tokenType = T ;
  char ch ;
  bool haveExit = false, eof = false ;
  ANodeOfSExpPtr inExpListHead = NULL, inExpListWalk = NULL ;
  gBufferToken.lexeme = "" ;
  scanf( "%d%c", &gTestNum, &ch ) ;
  cout << "Welcome to OurScheme!\n" ;
  while ( !haveExit && !eof ) {
    cout << "\n> " ;
    try {
      if ( inExpListHead == NULL ) {
        inExpListHead = ReadSExp( haveExit ) ;
        inExpListHead -> next = NULL ;
        inExpListWalk = inExpListHead ;
      } // if

      else {
        inExpListWalk -> next = ReadSExp( haveExit ) ;
        inExpListWalk = inExpListWalk -> next ;
        inExpListWalk -> next = NULL ;
      } // else

      if ( !haveExit ) {
        // evalExp
        // if evaluation error
        //   then PrintEvaluationError() ;
          
        // else // no evaluation error
        //   PrintSExp( resultSExp );
        TokenTreeNodePtr resultTokenTreeHead = EvalExp( inExpListWalk -> tokenTree.GetTokenTree(), true ) ;
        if ( resultTokenTreeHead == NULL ) { // change token tree only
          SkipWhiteSpace_special() ;
        } // if

        else {
          PrintSExp( inExpListWalk, resultTokenTreeHead ) ;
          SkipWhiteSpace_special() ;
        } // else
      } // if
    } // try

    catch ( ErrorType error_ ) {
      gBufferToken.lexeme = "" ;
      if ( error_.mEof ) {
        eof = true ;
        cout << error_.mMessage ;
      } // if

      else {
        cout << error_.mMessage ;
        if ( error_.mTokenTree != NULL )
          PrintTokenTree( error_.mTokenTree ) ;
        else 
          cout << endl ;

        if ( error_.mSkip ) 
          Skip_sameLine() ;
        else {
          SkipWhiteSpace_special() ;
        } // else          
      } // else
    } // catch
  } // while

  cout << "\nThanks for using OurScheme!" ;
} // main()

ANodeOfSExpPtr ReadSExp( bool &isExit ) { // if there has a white space in the end of input
  ANodeOfSExpPtr walk = NULL ;          // program will see it as the same line 
  vector<Token> tokenList ;             // fix it in function GetToken -> SkipWhiteSpace 

  if ( SExp( tokenList ) ) { 
    walk = new ANodeOfSExp ;
    walk -> tokenTree.Reset() ;
    walk -> tokenList = tokenList ;
    // if ( walk -> tokenList[0].lexeme == "\'" || walk -> tokenList[0].lexeme == "(" ) {
    walk -> tokenTree.BuildTokenTree( walk -> tokenList ) ;
    isExit = IsExit( walk ) ;
    // } // if
  } // if

  else {
    ErrorType error_ ;
    SExpError_type1( error_ ) ;
  } // else

  return walk ;
} // ReadSExp()

Token GetToken() {
  char ch ;
  Token token ;
  token.lexeme = "" ;
  bool firstIsSprt = true, endOfToken ;
  endOfToken = false ;
  SkipWhiteSpace() ;
  token.line = gLine ;
  token.column = gColumn ;
  while ( cin.peek() != EOF && !IsSeparator( cin.peek() ) ) {
    scanf( "%c", &ch ) ;
    gColumn++ ;
    if ( ch == ';' ) { // skip comment ;
      SkipComment() ;
      if ( token.lexeme == "" ) {
        SkipWhiteSpace() ;
        token.line = gLine ;
        token.column = gColumn ;
      } // if
    } // if

    else {
      token.lexeme += ch ;
      firstIsSprt = false ;
    }  // else
  } // while

  if ( cin.peek() == EOF && token.lexeme == "" ) {
    ErrorType error_ ;
    error_.mTokenTree = NULL ;
    error_.mEof = true ;
    error_.mMessage = "ERROR (no more input) : END-OF-FILE encountered" ;
    throw ( error_ ) ;
  } // if 
  
  if ( cin.peek() != EOF && firstIsSprt ) { // (, ), ', ", ;
    scanf( "%c", &ch ) ;
    gColumn++ ;
    if ( ch == '(' ) { // () == nil, may have ( )
      token.lexeme += '(' ;
    } // if

    else if ( ch == '"' ) { // string
      token.lexeme += ch ;
      bool error_ = false ;
      bool endStr = false ;
      while ( !endStr && cin.peek() != '\n' ) {
        scanf( "%c", &ch ) ;
        gColumn++ ;
        if ( ch == '\"' ) {
          token.lexeme += ch ;
          endStr = true ;
        } // if

        else if ( ch == '\\' ) {
          HandleBackslash( token.lexeme ) ;
        } // else if

        else {
          token.lexeme += ch ;
        } // else 
      } // while

      if ( !endStr ) {
        endStr = true ;
        stringstream s1, s2 ;
        string tempStr, trans ;
        ErrorType error_ ;
        error_.mTokenTree = NULL ;
        error_.mEof = false ;
        error_.mLine = gLine ;
        error_.mColumn = gColumn ;
        s1 << error_.mLine ;
        s1 >> trans ;
        s2 << error_.mColumn ;
        tempStr = "ERROR (no closing quote) : END-OF-LINE encountered at Line " + trans + " Column " ;
        s2 >> trans ;
        tempStr += trans ;
        error_.mMessage = tempStr ;
        error_.mSkip = true ;
        throw error_ ;
      } // if
    } // else if

    else {
      token.lexeme += ch ;
    } // else
  } // if

  if ( cin.peek() == '\n' ) {
    endOfToken = true ;
  } // if

  if ( token.lexeme == "t" ) {
    token.lexeme = "#t" ;
  } // if
  
  else if ( token.lexeme == "#f" ) { // nil, #f
    token.lexeme = "nil" ;
  } // else if

  token.tokenType = DefToken( token.lexeme ) ;
  return token ;
} // GetToken()

bool IsWhiteSpace( char ch ) { // ' ', '\n', '\t', end of file
  if ( ch == ' ' )
    return true ;
  else if ( ch == '\n' )
    return true ;
  else if ( ch == '\t' )
    return true ;
  else 
    return false ; 
} // IsWhiteSpace()

bool IsSeparator( char ch ) { // white space, '(', ')', '\'', '\"', ';' is seperator but return false here'
  if ( IsWhiteSpace( ch ) )
    return true ;
  else if ( ch == '(' )
    return true ;
  else if ( ch == ')' )
    return true ;
  else if ( ch == '\'' )
    return true ;
  else if ( ch == '\"' )
    return true ;
  else 
    return false ;
} // IsSeparator()

void SkipWhiteSpace() {
  while ( cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    gColumn++ ;
    if ( ch == '\n' ) {
      gLine++ ;
      gColumn = 1 ;
    } // if
  } // while
} // SkipWhiteSpace()

void SkipWhiteSpace_special() { // use it after find a SExp
  gLine = 1 ;
  gColumn = 1 ;
  bool enterEncounter = false ;
  while ( !enterEncounter && cin.peek() != EOF && IsWhiteSpace( cin.peek() ) ) {
    char ch ;
    scanf( "%c", &ch ) ;
    gColumn++ ;
    if ( ch == '\n' ) {
      enterEncounter = true ;
      gLine++ ;
      gColumn = 1 ;
    } // if
  } // while

  if ( !enterEncounter && cin.peek() == ';' ) { // skip line comment
    Skip_sameLine() ;
  } // if
} // SkipWhiteSpace_special()

void Skip_sameLine() { // use it when error encounter
  char ch ;
  if ( cin.peek() != '\n' ) {
    char cStr[256] ;
    cin.get( cStr, 256, '\n' ) ;
  } // if

  scanf( "%c", &ch ) ; // read '\\n'
  gLine = 1 ;
  gColumn = 1 ;
} // Skip_sameLine()

void SkipComment() {
  char cStr[256] ;
  cin.get( cStr, 256, '\n' ) ;
  gColumn = 1 ;
} // SkipComment() 

bool IsExit( ANodeOfSExpPtr aNodeHead ) {
  TokenTreeNodePtr walk = aNodeHead -> tokenTree.GetTokenTree() ;
  if ( walk == NULL || !walk -> internal )
    return false ;

  else {
    if ( walk -> left -> internal == false && walk -> right -> internal == false ) {
      if ( walk -> left -> token.lexeme == "exit" ) {
        if ( walk -> right -> token.tokenType == NIL )
          return true ;
      } // if
    } // if

    return false ;
  } // else
} // IsExit()

int DefToken( string lexeme ) {
  if ( lexeme == "(" ) {
    return LEFT_PAREN ;
  } // if

  else if ( lexeme == ")" ) {
    return RIGHT_PAREN ;
  } // else if

  else if ( lexeme == "." ) {
    return DOT ;
  } // else if

  else if ( lexeme[0] == '"' ) {
    return STRING ;
  } // else if

  else if ( lexeme == "nil" || lexeme == "#f" ) {
    return NIL ;
  } // else if

  else if ( lexeme == "t" || lexeme == "#t" ) {
    return T ;
  } // else if

  else if ( lexeme == "'" || lexeme == "\"" ) {
    return QUOTE ;
  } // else if

  else if ( IsNum( lexeme[0] ) || IsOperator( lexeme[0] ) || lexeme[0] == '.' ) { // int or float
    bool isFloat = false, haveADot = false ;
    bool isSymbol = false ;
    int i = 0 ;
    if ( lexeme[0] == '+' || lexeme[0] == '-' ) {
      i++ ;
      if ( lexeme.size() == 1 )
        isSymbol = true ;
    } // if

    for ( ; i < lexeme.size() ; i++ ) {
      if ( lexeme[i] == '.' && !haveADot ) {
        isFloat = true ;
        haveADot = true ;
        if ( lexeme.size() == 2 && !IsNum( lexeme[1-i] ) ) // +., -.
          isSymbol = true ;
      } // if

      else if ( !IsNum( lexeme[i] ) ) {
        isSymbol = true ;
      } // else if
    } // for

    if ( isSymbol )
      return SYMBOL ;
    else if ( isFloat )
      return FLOAT ;
    else 
      return INT ;
    // may have error_ 
  } // else if

  else { // symbol
    return SYMBOL ;
    // maybe have error_ 
  } // else 
} // DefToken()

bool IsNum( char ch ) {
  if ( ch >= '0' && ch <= '9' )
    return true ;

  return false ;
} // IsNum()

bool IsOperator( char ch ) { // +,-,*,/
  if ( ch == '+' ) 
    return true ;

  else if ( ch == '-' )
    return true ;

  else if ( ch == '*' )
    return true ;

  else if ( ch == '/' )
    return true ;

  else 
    return false ;
} // IsOperator()

void HandleBackslash( string &token ) {
  char ch = '\\' ;
  gColumn++ ;
  if ( cin.peek() == '\"' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // if

  else if ( cin.peek() == '\\' ) {
    scanf( "%c", &ch ) ;
    token += ch ;
  } // else if
 
  else if ( cin.peek() == 'n' ) {
    scanf( "%c", &ch ) ;
    token += '\n' ;   
  } // else if

  else if ( cin.peek() == 't' ) {
    scanf( "%c", &ch ) ;
    token += '\t' ;
  } // else if

  else {
    gColumn-- ;
    token += ch ;
  } // else
} // HandleBackslash()

void PrintSExp( ANodeOfSExpPtr head, TokenTreeNodePtr resultHead ) {
  TokenTreeNodePtr tokenTreeHead = head -> tokenTree.GetTokenTree() ;
  PrintTokenTree( resultHead ) ;
} // PrintSExp()

void PrintTokenTree( TokenTreeNodePtr head ) {
  int spaceCount = 1 ;
  PrintTokenTreeRecur( head, head, spaceCount, true ) ;
} // PrintTokenTree()

void PrintTokenTreeRecur( TokenTreeNodePtr head, TokenTreeNodePtr walk, int spaceCount, bool first ) { 
  if ( walk == head && walk -> internal ) {
    bool firstBrace = false ;
    cout << "( " ;
    if ( head -> left -> internal ) {
      cout << "( " ;
      firstBrace = true ;
    } // if

    PrintTokenTreeRecur( head, head -> left, spaceCount+1, true ) ;
    if ( firstBrace ) {
      cout << "  )\n" ; 
    } // if 

    if ( walk -> right -> internal ) {
      PrintTokenTreeRecur( head, head -> right, spaceCount, false ) ;
    } // if

    else {
      if ( walk -> right -> token.tokenType != NIL ) {
        cout << "  .\n" ;
        PrintTokenTreeRecur( head, head -> right, spaceCount, false ) ;
      } // if
    } // else

    cout << ")\n" ;
  } // if

  else if ( walk == NULL ) {
    ;
  } // else if

  else {
    // if is internal node
    //   if ( now -> left == internal )
    //     recursive left,spaceCount+1
    //     recursive right,spaceCount+1
    //   else
    //     recursive left,spaceCount
    //     recursive right,spaceCount
    //   return 

    // else 
    //   if is right is nil
    //     cout << sapce << right_paren
    //   else
    //     cout << space << token
    if ( walk -> internal ) {
      if ( walk -> left -> internal ) {
        if ( !first ) {
          for ( int i = 0 ; i < spaceCount ; i++ )
            cout << "  " ;
        } // if

        cout << "( " ;
        PrintTokenTreeRecur( head, walk -> left, spaceCount+1, true ) ;

        for ( int i = 0 ; i < spaceCount ; i++ ) {
          cout << "  " ;
        } // for 

        cout << ")\n" ;

        if ( !walk -> right -> internal ) {
          if ( walk -> right -> token.tokenType != NIL ) {
            for ( int i = 0 ; i < spaceCount ; i++ )
              cout << "  " ;

            cout << ".\n" ;
            PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
          } // if
        } // if
 
        else {
          PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
        } // else
      } // if

      else {
        PrintTokenTreeRecur( head, walk -> left, spaceCount, first ) ;

        if ( walk -> right -> internal ) {
          PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
        } // if

        else {
          if ( walk -> right -> token.tokenType != NIL ) {
            for ( int i = 0 ; i < spaceCount ; i++ ) {
              cout << "  " ;
            } // for 

            cout << ".\n" ;
            PrintTokenTreeRecur( head, walk -> right, spaceCount, false ) ;
          } // if 
        } // else
      } // else
    } // if

    else {
      if ( !first ) {
        for ( int i = 0 ; i < spaceCount ; i++ ) {
          cout << "  " ;
        } // for 
      } // if

      stringstream s1 ;
      if ( walk -> token.tokenType == INT ) { // handle +123, +12.3, -5.6363
        int tempInt ;
        s1 << walk -> token.lexeme ;
        s1 >> tempInt ;
        cout << tempInt << endl ;
      } // if

      else if ( walk -> token.tokenType == FLOAT ) { // +123.5,-5.6363,-9.2
        float tempInt ;
        s1 << walk -> token.lexeme ;
        s1 >> tempInt ;
        printf( "%.3f\n", tempInt ) ;
      } // else if

      else {
        cout << walk -> token.lexeme << endl ;
      } // else
    } // else 
  } // else
} // PrintTokenTreeRecur()

void TokenTree :: BuildTokenTree( vector<Token> tokenList ) {
  // stack store every return token tree node
  stack<TokenTreeNodePtr> nodeS ;
  TokenTreeNodePtr walk = mHead ;
  for ( int i = 0 ; i < tokenList.size() ; i++ ) {
    string keyStr = tokenList[i].lexeme ;
    if ( keyStr == "(" || keyStr == "\'" ) {
      mParentheseCount++ ;

      if ( mHead == NULL ) {
        mHead = new TokenTreeNode ;
        mHead -> internal = true ;
        mHead -> left = NULL ;
        mHead -> right = NULL ;
        walk = mHead ;
        if ( keyStr != "\'" ) 
          nodeS.push( walk ) ;
        
        else {
          HandleQuoteTree( walk, tokenList[i] ) ;
        } // else
        
      } // if

      else if ( !walk -> internal ) {
        nodeS.pop() ;
        walk = nodeS.top() ;
        nodeS.pop() ;
        if ( walk -> right != NULL )
          cout << "unexpected error_:line 535\n" ;

        else {
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = new TokenTreeNode ;
          walk -> right = NULL ; 
          nodeS.push( walk ) ;

          walk = walk -> left ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          if ( keyStr != "\'" )  
            nodeS.push( walk ) ;
          else {
            HandleQuoteTree( walk, tokenList[i] ) ;
          } // else
        } // else
      } // else if

      else {
        if ( walk -> left == NULL ) {
          walk -> left = new TokenTreeNode ;
          walk = walk -> left ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          if ( keyStr != "\'" )
            nodeS.push( walk ) ; 
          else { // keyStr == "\'"
            HandleQuoteTree( walk, tokenList[i] ) ;
          } // else
        } // if

        else if ( walk -> right == NULL ) {
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          if ( keyStr != "\'" )
            nodeS.push( walk ) ; 
          else { // keyStr == "\'"
            HandleQuoteTree( walk, tokenList[i] ) ;
          } // else
        } // else if 

        else { // walk -> left != NULL && right != NULL 
          nodeS.pop() ;
          walk = nodeS.top() ;
          nodeS.pop() ;
          if ( walk -> right == NULL ) {
            walk -> right = new TokenTreeNode ;
            walk = walk -> right ;

            walk -> internal = true ;
            walk -> left = new TokenTreeNode ;
            walk -> right = NULL ;
            nodeS.push( walk ) ; // may heve problem,can't back to head 

            walk = walk -> left ;
            walk -> internal = true ;
            walk -> left = NULL ; 
            walk -> right = NULL ;
            if ( keyStr != "\'" )
              nodeS.push( walk ) ;
            else {
              HandleQuoteTree( walk, tokenList[0] ) ;
            } // else
          } // if

          else {
            cout << "it's happening!!\n" ; // walk -> right != NULL 
          } // else
        } // else
      } // else
    } // if

    else if ( keyStr == ")" ) {
      if ( tokenList[i-1].lexeme == "(" ) {
        cout << "unexpected error_:line 602\n" ;
      } // if

      mParentheseCount-- ;
      nodeS.pop() ;
      walk = nodeS.top() ;
      if ( walk ->  right == NULL ) {
        Token tempToken ;
        tempToken.lexeme = "nil" ;
        tempToken.tokenType = NIL ;
        walk -> right = new TokenTreeNode ;
        walk -> right -> left = NULL ;
        walk -> right -> right = NULL ;
        walk -> right -> token = tempToken ;
        walk -> right -> internal = false ;
      } // if
    } // else if

    else if ( keyStr == "." ) {
      nodeS.pop() ;
      walk = nodeS.top() ;
      if ( walk -> right != NULL ) {
        TokenTreeNodePtr temp = new TokenTreeNode ;
        temp -> internal = true ;
        temp -> left = walk -> right ;
        temp -> right = NULL ;
        walk -> right = temp ;
        walk = walk -> right ;
        // no need push into stack??
      } // if
    } // else if

    else { // int, float, symbol
      if ( walk == NULL ) {
        if ( mHead == NULL ) {
          mHead = new TokenTreeNode ;
          mHead -> internal = false ;
          mHead -> left = NULL ;
          mHead -> right = NULL ;
          mHead -> token = tokenList[i] ;
        } // if
   
        else {
          cout << "imposible token tree error:line 685\n" ;
          exit( 0 ) ;
        } // else
      } // if

      else if ( !walk -> internal ) { // may have a problem
        nodeS.pop() ;
        walk = nodeS.top() ;
        if ( walk -> right != NULL ) {
          cout << "unexpected error_:line639\n" ;
        } // if

        else {
          walk -> right = new TokenTreeNode ;
          walk = walk -> right ;
          walk -> internal = true ;
          walk -> left = new TokenTreeNode ;

          if ( tokenList[i+1].tokenType == RIGHT_PAREN ) {
            Token tempToken ;
            tempToken.lexeme = "nil" ;
            tempToken.tokenType = NIL ;
            walk -> right = new TokenTreeNode ;
            walk -> right -> left = NULL ;
            walk -> right -> right = NULL ;
            walk -> right -> token = tempToken ;
            walk -> right -> internal = false ;
          } // if

          else {
            nodeS.pop() ;
            nodeS.push( walk ) ;
            walk -> right = NULL ;
          } // else

          walk = walk -> left ;
          walk -> left = NULL ;
          walk -> right = NULL ;
          walk -> internal = false ;
          walk -> token = tokenList[i] ;
          nodeS.push( walk ) ;
        } // else
      } // if

      else if ( walk -> left == NULL ) {
        walk -> left = new TokenTreeNode ;
        walk = walk -> left ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( walk ) ;
      } // if

      else if ( walk -> right == NULL ) {
        walk -> right = new TokenTreeNode ;
        walk = walk -> right ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> internal = false ;
        walk -> token = tokenList[i] ;
        nodeS.push( walk ) ;
      } // else if

      else {
        nodeS.pop() ;
        walk = nodeS.top() ;
        nodeS.pop() ;
        walk -> right = new TokenTreeNode ;
        walk = walk -> right ;

        walk -> internal = true ; 
        walk -> left = new TokenTreeNode ;
        walk -> right = NULL ;
        nodeS.push( walk ) ;

        walk = walk -> left ;
        walk -> internal = false ;
        walk -> left = NULL ;
        walk -> right = NULL ;
        walk -> token = tokenList[i] ;
        nodeS.push( walk ) ;
      } // else
    } // else
  } // for
} // TokenTree::BuildTokenTree()

void TokenTree :: HandleQuoteTree( TokenTreeNodePtr &walk, Token quote ) { 
  walk -> left = new TokenTreeNode ; // now -> left = quote, right = new ;               

  walk -> left -> left = NULL ; // put quote in
  walk -> left -> right = NULL ;
  walk -> left -> internal = false ;
  walk -> left -> token = quote ;
  walk -> left -> token.lexeme = "quote" ;
  walk -> left -> token.tokenType = SYMBOL ;

  walk -> right = new TokenTreeNode ; // now -> right -> right = nil 
  walk = walk -> right ;              // deal with quote node
  walk -> left = NULL ;               // add internal node 
  walk -> right = new TokenTreeNode ;
  walk -> internal = true ;
            
  walk -> right -> left = NULL ; // put nil in 
  walk -> right -> right = NULL ;
  walk -> right -> internal = false ;
  walk -> right -> token.lexeme = "nil" ;
  walk -> right -> token.tokenType = NIL ;
} // TokenTree::HandleQuoteTree()

bool Atom( vector<Token> &tokenList ) {
  Token token = PeekToken() ;
  if ( token.tokenType == SYMBOL || token.tokenType == INT || token.tokenType == FLOAT ||
       token.tokenType == STRING || token.tokenType == NIL || token.tokenType == T ) {
    tokenList.push_back( token ) ;
    gBufferToken.lexeme = "" ;
    return true ;
  } // if

  else if ( token.tokenType == LEFT_PAREN ) {
    int tempLine = token.line, tempColumn = token.column ;
    SkipWhiteSpace() ;
    if ( cin.peek() == ')' ) {
      char ch ;
      gBufferToken.lexeme = "" ;
      scanf( "%c", &ch ) ;
      
      Token nilToken ;
      nilToken.lexeme = "nil" ;
      nilToken.line = tempLine ;
      nilToken.column = tempColumn ;
      nilToken.tokenType = NIL ;
      tokenList.push_back( nilToken ) ;
      return true ;
    } // if
  } // else if

  return false ;
} // Atom()

bool SExp( vector<Token> &tokenList ) {
  if ( Atom( tokenList ) ) {
    return true ;
  } // if

  else if ( PeekToken().tokenType == LEFT_PAREN ) {
    tokenList.push_back( PeekToken() ) ;
    gBufferToken.lexeme = "" ;
    if ( SExp( tokenList ) ) {
      while ( SExp( tokenList ) ) {
        ;
      } // while

      if ( PeekToken().lexeme == "." ) {
        tokenList.push_back( PeekToken() ) ;
        gBufferToken.lexeme = "" ;
        if ( !SExp( tokenList ) ) {
          tokenList.push_back( PeekToken() ) ;
          ErrorType error_ ;
          SExpError_type1( error_ ) ;
          return false ;
        } // if
      } // if

      if ( PeekToken().lexeme == ")" ) {
        tokenList.push_back( PeekToken() ) ;
        gBufferToken.lexeme = "" ;
        return true ;
      } // else if

      else {
        tokenList.push_back( PeekToken() ) ;
        ErrorType error_ ;
        SExpError_type2( error_ ) ;
        return false ;
      } // else 
    } // if

    else {
      tokenList.push_back( PeekToken() ) ;
      ErrorType error_ ;
      SExpError_type1( error_ ) ;
      return false ;
    } // else
  } // else if

  else if ( PeekToken().tokenType == QUOTE ) {
    tokenList.push_back( PeekToken() ) ;
    gBufferToken.lexeme = "" ;
    return SExp( tokenList ) ;
  } // else if

  else {
    return false ;
  } // else
} // SExp()

Token PeekToken() {
  if ( gBufferToken.lexeme == "" ) {
    gBufferToken = GetToken() ;
  } // if

  return gBufferToken ;
} // PeekToken()

void SExpError_type1( ErrorType error_ ) {
  error_.mTokenTree = NULL ;
  error_.mEof = false ;
  error_.mLine = PeekToken().line ;
  error_.mColumn = PeekToken().column ;
  stringstream s1, s2 ;
  string tempStr, trans ;
  s1 << error_.mLine ;
  s1 >> trans ;
  s2 << error_.mColumn ;
  tempStr = "ERROR (unexpected token) : atom or '(' expected when token at Line " + trans + " Column " ;
  s2 >> trans ;
  tempStr += trans + " is >>" + PeekToken().lexeme + "<<" ;
  error_.mMessage = tempStr ;
  error_.mSkip = true ;
  throw error_ ;
} // SExpError_type1()

void SExpError_type2( ErrorType error_ ) {
  error_.mTokenTree = NULL ;
  error_.mEof = false ;
  error_.mLine = PeekToken().line ;
  error_.mColumn = PeekToken().column ;
  stringstream s1, s2 ;
  string tempStr, trans ;
  s1 << error_.mLine ;
  s1 >> trans ;
  s2 << error_.mColumn ;
  tempStr = "ERROR (unexpected token) : ')' expected when token at Line " + trans + " Column " ;
  s2 >> trans ;
  tempStr += trans + " is >>" + PeekToken().lexeme + "<<" ;
  error_.mMessage = tempStr ;
  error_.mSkip = true ;
  throw error_ ;
} // SExpError_type2()

TokenTreeNodePtr EvalExp( TokenTreeNodePtr inTokenTreeHead, bool topFunc ) {
  if ( !inTokenTreeHead -> internal ) { // what is being evaluated is Atom
    // if what is being evaluated is a symbol 
    if ( inTokenTreeHead -> token.tokenType == SYMBOL ) {
      // check whether it is bound to an S-expression or an internal function
      // if unbound,ERROR (unbound symbol) : abc
      TokenTreeNodePtr bindingTreeHead = gDefineTable.GetSymbolTree( inTokenTreeHead -> token.lexeme ) ;
      if ( bindingTreeHead == NULL ) { 
        ErrorType error_ ;
        error_.mMessage = "ERROR (unbound symbol) : " + inTokenTreeHead -> token.lexeme ;
        throw error_ ;
      } // if
 
      else { // else, return that S-expression or internal function (i.e., its binding)
        return bindingTreeHead ;
      } // else
    } // if

    // else if what is being evaluated is an atom but not a symbol
    else {
      return inTokenTreeHead ;
    } // else
  } // if

  else { // ( inTokenTreeHead -> internal ) // what is being evaluated is (...)
    // find first argument
    bool toplevel = true ;
    Token firstArg = FindFirstArg( inTokenTreeHead -> left, toplevel ) ;
    
    if ( !IsList( inTokenTreeHead ) ) {
      ErrorType error_ ;
      error_.mTokenTree = inTokenTreeHead ;
      error_.mMessage = "ERROR (non-list) : " ;
      throw error_ ;
    } // if

    // first argment is an Atom but not Symbol
    else if ( firstArg.tokenType != SYMBOL && firstArg.tokenType != PRIMITIVE ) { 
      ErrorType error_ ;
      if ( firstArg.tokenType == FLOAT ) {
        stringstream s1, s2 ; 
        float temp ;
        s1 << firstArg.lexeme ;
        s1 >> temp ;
        s2 << fixed << setprecision( 3 ) << temp ;
        s2 >> firstArg.lexeme ;
      } // if

      error_.mMessage = "ERROR (attempt to apply non-function) : " + firstArg.lexeme ;
      throw error_ ;
    } // else if

    // first argment is a Symbol 
    else if ( firstArg.tokenType == SYMBOL || firstArg.tokenType == PRIMITIVE ) { 
      string sym ; 
      if ( gDefineTable.IsInternalFunc( firstArg, sym ) ) { // if SYM is the name of a known function
        if ( !topFunc && ( sym == "clean-environment" || sym == "define" || sym == "exit" ) ) {
          ErrorType error_ ;
          if ( sym == "clean-environment" )
            sym = "CLEAN-ENVIRONMENT" ;
          else if ( sym == "define" )
            sym = "DEFINE" ;
          else // sym == "exit"
            sym = "EXIT" ;

          error_.mMessage = "ERROR (level of " + sym + ")" ;
          throw error_ ; 
        } // if

        else if ( sym == "define" || sym == "cond" ) {
          // check format of exp
          if ( sym == "define" && Define( inTokenTreeHead ) ) { 
            return Evaluate( "define", inTokenTreeHead ) ; 
          } // if
 
          else if ( sym == "cond" && Cond( inTokenTreeHead ) ) { 
            return Evaluate( "cond", inTokenTreeHead ) ;
          } // else if

          else {
            ErrorType error_ ;
            if ( sym == "define" )
              sym = "DEFINE" ;
            else 
              sym = "COND" ;

            error_.mMessage = "ERROR (" + sym + " format) : " ;
            error_.mTokenTree = inTokenTreeHead ;
            throw error_ ;
          } // else
        } // else if

        else if ( !toplevel ) {
          inTokenTreeHead -> left = EvalExp( inTokenTreeHead -> left, false ) ;
          if ( topFunc && inTokenTreeHead -> left -> internal ) { // cmd is (...)
            ErrorType error_ ;
            error_.mMessage = "ERROR (attempt to apply non-function) : " ;
            error_.mTokenTree = inTokenTreeHead -> left ;
            throw error_ ;
          } // if

          return EvalExp( inTokenTreeHead, topFunc ) ;
        } // else if
 
        else if ( sym == "if" ) {
          if ( !CheckArgNum( sym, inTokenTreeHead ) ) {
            ErrorType error_ ;
            error_.mMessage = "ERROR (incorrect number of arguments) : " + sym ;
            throw error_ ;
          } // if

          return EvalExp( Evaluate( sym, inTokenTreeHead ), false ) ;
        } // else if

        else { // SYM is a known function name 'abc', which is neither 
               // 'define' nor 'let' nor 'cond' nor 'lambda'
               // check whether the number of arguments is correct
               // if number of arguments is NOT correct
               //   ERROR (incorrect number of arguments) : abc
          if ( !CheckArgNum( sym, inTokenTreeHead ) ) {
            ErrorType error_ ;
            error_.mMessage = "ERROR (incorrect number of arguments) : " + sym ;
            throw error_ ;
          } // if

          return Evaluate( sym, inTokenTreeHead ) ;
        } // else
      } // if

      else {
        ErrorType error_ ;
        TokenTreeNodePtr binding = gDefineTable.GetSymbolTree( firstArg.lexeme ) ;
        if ( binding == NULL )  
          error_.mMessage = "ERROR (unbound symbol) : " + firstArg.lexeme ;

        else {
          error_.mMessage = "ERROR (attempt to apply non-function) : " ;
          error_.mTokenTree = binding ;
        } // else

        throw error_ ;
      } // else
    } // else if 

    else { // first argment is (...) 
      cout << "error only project3 needed line:1331" ; // evaluate (...) 
      return NULL ;
    } // else if
  } // else

  return NULL ;
} // EvalExp()

TokenTreeNodePtr Evaluate( string cmd, TokenTreeNodePtr inHead ) { // already check num of argument
  if ( cmd == "define" ) {
    TokenTreeNodePtr bindingHead = EvalExp( inHead -> right -> right -> left, false ) ;
    string bindingSymbol = inHead -> right -> left -> token.lexeme ;
    gDefineTable.BindingSymbol( bindingSymbol, bindingHead ) ;
    cout << bindingSymbol + " defined\n" ;
    return NULL ;
  } // if

  else if ( cmd == "car" || cmd == "cdr" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ; // find second arg
    if ( !arg -> internal ) {
      ErrorType error_ ;
      if ( arg -> token.tokenType == FLOAT ) {
        stringstream s1, s2 ; 
        float temp ;
        s1 << arg -> token.lexeme ;
        s1 >> temp ;
        s2 << fixed << setprecision( 3 ) << temp ;
        s2 >> arg -> token.lexeme  ;
      } // if

      error_.mMessage = "ERROR (" + cmd + " with incorrect argument type) : " + arg -> token.lexeme ;
      throw error_ ;
    } // if

    if ( cmd == "car" ) {
      return arg -> left ;
    } // if

    else { // cmd == "cdr"
      return arg -> right ;
    } // else 
  } // else if

  else if ( cmd == "quote" ) {
    TokenTreeNodePtr secondArg = inHead -> right -> left ; // find second arg
    return secondArg ;
  } // else if

  else if ( cmd == "cons" ) {
    TokenTreeNodePtr resultHead = new TokenTreeNode ;
    resultHead -> internal = true ;
    TokenTreeNodePtr arg2 = inHead -> right -> left ;
    TokenTreeNodePtr arg3 = inHead -> right -> right -> left ;
    resultHead -> left = EvalExp( arg2, false ) ;
    resultHead -> right = EvalExp( arg3, false ) ;
    return resultHead ;
  } // else if

  else if ( cmd == "list" ) {
    TokenTreeNodePtr resultHead = NULL, resultWalk = resultHead ;

    inHead = inHead -> right ;
    while ( inHead -> right != NULL ) {
      if ( resultHead == NULL ) {
        resultHead = new TokenTreeNode ;
        resultHead -> left = EvalExp( inHead -> left, false ) ;
        resultHead -> right = gNilTokenPtr ;
        resultHead -> internal = true ;
        resultWalk = resultHead ;
      } // if

      else {
        resultWalk -> right = new TokenTreeNode ;
        resultWalk = resultWalk -> right ;
        resultWalk -> left = EvalExp( inHead -> left, false ) ;
        resultWalk -> right = gNilTokenPtr ;
        resultWalk -> internal = true ;
      } // else

      inHead = inHead -> right ;
    } // while

    if ( resultHead == NULL )
      resultHead = gNilTokenPtr ;

    return resultHead ;
  } // else if

  else if ( cmd == "atom?" ) {
    TokenTreeNodePtr arg = inHead -> right -> left ;
    arg = EvalExp( arg, false ) ;
    if ( arg -> internal ) {
      return gNilTokenPtr ;
    } // if

    else {
      return gTTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "pair?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( arg -> internal )
      return gTTokenPtr ;

    return gNilTokenPtr ;
  } // else if

  else if ( cmd == "list?" ) {
    TokenTreeNodePtr arg = inHead -> right -> left ;
    arg = EvalExp( arg, false ) ;
    if ( IsList( arg ) ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "null?" ) {
    TokenTreeNodePtr arg = inHead -> right -> left ;
    arg = EvalExp( arg, false ) ;
    if ( !arg -> internal && arg -> token.tokenType == NIL ) {
      return gTTokenPtr ;
    } // if
      
    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "integer?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( arg -> token.tokenType == INT ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "real?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "number?" ) { // in OurSchem, real? = number?, but not in Scheme 
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ; // (there are complex-numbers)
    if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "string?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( arg -> token.tokenType == STRING ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "boolean?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( arg -> token.tokenType == T || arg -> token.tokenType == NIL ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "symbol?" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( arg -> token.tokenType == SYMBOL ) {
      return gTTokenPtr ;
    } // if

    else {
      return gNilTokenPtr ;
    } // else
  } // else if

  else if ( cmd == "+" ) {
    int num_int = 0, result_int = 0 ;
    float num_float = 0, result_float = 0 ;
    bool isFloat = false ;
    inHead = inHead -> right ;
    do {
      TokenTreeNodePtr arg = EvalExp( inHead -> left, false ) ;
      if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
        stringstream s1 ;
        s1 << arg -> token.lexeme ; 
        if ( arg -> token.tokenType == FLOAT || isFloat ) {
          if ( !isFloat )
            result_float = result_int ;

          isFloat = true ;
          s1 >> num_float ;
          result_float += num_float ;
        } // if
   
        else {
          s1 >> num_int ;
          result_int += num_int ;
        } // else
  
        inHead = inHead -> right ;
      } // if
  
      else {
        ErrorType error_ ;
        error_.mMessage = "ERROR (+ with incorrect argument type) : " ;
        error_.mTokenTree = arg ;
        throw error_ ;
      } // else
    } while ( inHead -> right != NULL ) ;

    TokenTreeNodePtr result = new TokenTreeNode ;
    result -> left = NULL ;
    result -> right = NULL ;
    result -> internal = false ;
    stringstream s1 ;
    if ( isFloat ) {
      result -> token.tokenType = FLOAT ;
      s1 << result_float ;
    } // if

    else {
      result -> token.tokenType = INT ;
      s1 << result_int ;
    } // else

    s1 >> result -> token.lexeme ;
    return result ; 
  } // else if

  else if ( cmd == "-" ) {
    int num_int = 0, result_int = 0 ;
    float num_float = 0, result_float = 0 ;
    bool isFloat = false, first = true ;
    inHead = inHead -> right ;
    do {
      TokenTreeNodePtr arg = EvalExp( inHead -> left, false ) ;
      if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
        stringstream s1 ;
        s1 << arg -> token.lexeme ; 
        if ( arg -> token.tokenType == FLOAT || isFloat ) {
          if ( !isFloat )
            result_float = result_int ;

          isFloat = true ;
          s1 >> num_float ;
          if ( first ) {
            result_float = num_float ;
            first = false ;
          } // if

          else 
            result_float -= num_float ;
        } // if
   
        else {
          s1 >> num_int ;
          if ( first ) {
            result_int = num_int ;
            first = false ;
          } // if

          else 
            result_int -= num_int ;
        } // else
  
        inHead = inHead -> right ;
      } // if
  
      else {
        ErrorType error_ ;
        error_.mMessage = "ERROR (- with incorrect argument type) : " ;
        error_.mTokenTree = arg ;
        throw error_ ;
      } // else
    } while ( inHead -> right != NULL ) ;

    TokenTreeNodePtr result = new TokenTreeNode ;
    result -> left = NULL ;
    result -> right = NULL ;
    result -> internal = false ;
    stringstream s1 ;
    if ( isFloat ) {
      result -> token.tokenType = FLOAT ;
      s1 << result_float ;
    } // if

    else {
      result -> token.tokenType = INT ;
      s1 << result_int ;
    } // else

    s1 >> result -> token.lexeme ;
    return result ; 
  } // else if

  else if ( cmd == "*" ) {
    int num_int = 0, result_int = 1 ;
    float num_float = 0, result_float = 1 ;
    bool isFloat = false ;
    inHead = inHead -> right ;
    do {
      TokenTreeNodePtr arg = EvalExp( inHead -> left, false ) ;
      if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
        stringstream s1 ;
        s1 << arg -> token.lexeme ; 
        if ( arg -> token.tokenType == FLOAT || isFloat ) {
          if ( !isFloat )
            result_float = result_int ;

          isFloat = true ;
          s1 >> num_float ;
          result_float *= num_float ;
        } // if
   
        else {
          s1 >> num_int ;
          result_int *= num_int ;
        } // else
  
        inHead = inHead -> right ;
      } // if
  
      else {
        ErrorType error_ ;
        error_.mMessage = "ERROR (* with incorrect argument type) : " ;
        error_.mTokenTree = arg ;
        throw error_ ;
      } // else
    } while ( inHead -> right != NULL ) ;

    TokenTreeNodePtr result = new TokenTreeNode ;
    result -> left = NULL ;
    result -> right = NULL ;
    result -> internal = false ;
    stringstream s1 ;
    if ( isFloat ) {
      result -> token.tokenType = FLOAT ;
      s1 << result_float ;
    } // if

    else {
      result -> token.tokenType = INT ;
      s1 << result_int ;
    } // else

    s1 >> result -> token.lexeme ;
    return result ; 
  } // else if

  else if ( cmd == "/" ) {
    int num_int = 0, result_int = 0 ;
    float num_float = 0, result_float = 0 ;
    bool isFloat = false, first = true ;
    inHead = inHead -> right ;
    do {
      TokenTreeNodePtr arg = EvalExp( inHead -> left, false ) ;
      if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
        stringstream s1 ;
        s1 << arg -> token.lexeme ; 
        if ( arg -> token.tokenType == FLOAT || isFloat ) {
          if ( !isFloat )
            result_float = result_int ;

          isFloat = true ;
          s1 >> num_float ;
          if ( first ) {
            result_float = num_float ;
            first = false ;
          } // if

          else {
            if ( num_float == 0 ) {
              ErrorType error_ ;
              error_.mMessage = "ERROR (division by zero) : /" ;
              throw error_ ;
            } // if
 
            result_float = result_float / num_float ;
          } // else
        } // if
   
        else {
          s1 >> num_int ;
          if ( first ) {
            result_int = num_int ;
            first = false ;
          } // if

          else {
            if ( num_int == 0 ) {
              ErrorType error_ ;
              error_.mMessage = "ERROR (division by zero) : /" ;
              throw error_ ;
            } // if

            result_int = result_int / num_int ;
          } // else
        } // else
  
        inHead = inHead -> right ;
      } // if
  
      else {
        ErrorType error_ ;
        error_.mMessage = "ERROR (/ with incorrect argument type) : " ;
        error_.mTokenTree = arg ;
        throw error_ ;
      } // else
    } while ( inHead -> right != NULL ) ;

    TokenTreeNodePtr result = new TokenTreeNode ;
    result -> left = NULL ;
    result -> right = NULL ;
    result -> internal = false ;
    stringstream s1 ;
    if ( isFloat ) {
      result -> token.tokenType = FLOAT ;
      s1 << result_float ;
    } // if

    else {
      result -> token.tokenType = INT ;
      s1 << result_int ;
    } // else

    s1 >> result -> token.lexeme ;
    return result ; 
  } // else if

  else if ( cmd == ">" ) {
    bool isBigger = true ;
    while ( inHead -> right -> right -> internal && isBigger ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      int main_int = 0, contrast_int = 0 ;
      float main_float = 0, contrast_float = 0 ;
      bool isFirst = true, mainIsFloat = false ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
          stringstream s1 ;
          s1 << arg -> token.lexeme ; 
          if ( isBigger && arg -> token.tokenType == FLOAT ) { // deal with float
            if ( isFirst ) {
              s1 >> main_float ;
              isFirst = false ;
              mainIsFloat = true ;
            } // if
  
            else { // do contrast(float)
              s1 >> contrast_float ;
              if ( mainIsFloat )
                isBigger = ( main_float > contrast_float ) ;
              else 
                isBigger = ( main_int > contrast_float ) ;
            } // else 
          } // if
     
          else if ( isBigger ) { // deal with int 
            if ( isFirst ) {
              s1 >> main_int ;
              isFirst = false ;
            } // if
  
            else { // do contrast (int) 
              s1 >> contrast_int ;
              if ( mainIsFloat )
                isBigger = ( main_float > contrast_int ) ;
              else 
                isBigger = ( main_int > contrast_int ) ;
            } // else
          } // else if
    
          walk = walk -> right ;
        } // if
    
        else {
          ErrorType error_ ;
          error_.mMessage = "ERROR (> with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // else
      } while ( walk -> internal ) ;
    } // while

    if ( isBigger )
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == ">=" ) {
    bool isBiggerEqual = true ;
    while ( inHead -> right -> right -> internal && isBiggerEqual ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      int main_int = 0, contrast_int = 0 ;
      float main_float = 0, contrast_float = 0 ;
      bool isFirst = true, mainIsFloat = false ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
          stringstream s1 ;
          s1 << arg -> token.lexeme ; 
          if ( isBiggerEqual && arg -> token.tokenType == FLOAT ) { // deal with float
            if ( isFirst ) {
              s1 >> main_float ;
              isFirst = false ;
              mainIsFloat = true ;
            } // if
  
            else { // do contrast(float)
              s1 >> contrast_float ;
              if ( mainIsFloat )
                isBiggerEqual = ( main_float >= contrast_float ) ;
              else 
                isBiggerEqual = ( main_int >= contrast_float ) ;
            } // else 
          } // if
     
          else if ( isBiggerEqual ) { // deal with int 
            if ( isFirst ) {
              s1 >> main_int ;
              isFirst = false ;
            } // if
  
            else { // do contrast (int) 
              s1 >> contrast_int ;
              if ( mainIsFloat )
                isBiggerEqual = ( main_float >= contrast_int ) ;
              else 
                isBiggerEqual = ( main_int >= contrast_int ) ;
            } // else
          } // else if
    
          walk = walk -> right ;
        } // if
    
        else {
          ErrorType error_ ;
          error_.mMessage = "ERROR (>= with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // else
      } while ( walk -> internal ) ;
    } // while


    if ( isBiggerEqual )
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "<" ) {
    bool isLess = true ;
    while ( inHead -> right -> right -> internal && isLess ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      int main_int = 0, contrast_int = 0 ;
      float main_float = 0, contrast_float = 0 ;
      bool isFirst = true, mainIsFloat = false ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
          stringstream s1 ;
          s1 << arg -> token.lexeme ; 
          if ( isLess && arg -> token.tokenType == FLOAT ) { // deal with float
            if ( isFirst ) {
              s1 >> main_float ;
              isFirst = false ;
              mainIsFloat = true ;
            } // if
  
            else { // do contrast(float)
              s1 >> contrast_float ;
              if ( mainIsFloat )
                isLess = ( main_float < contrast_float ) ;
              else 
                isLess = ( main_int < contrast_float ) ;
            } // else 
          } // if
     
          else if ( isLess ) { // deal with int 
            if ( isFirst ) {
              s1 >> main_int ;
              isFirst = false ;
            } // if
  
            else { // do contrast (int) 
              s1 >> contrast_int ;
              if ( mainIsFloat )
                isLess = ( main_float < contrast_int ) ;
              else 
                isLess = ( main_int < contrast_int ) ;
            } // else
          } // else if
    
          walk = walk -> right ;
        } // if
    
        else {
          ErrorType error_ ;
          error_.mMessage = "ERROR (< with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // else
      } while ( walk -> internal ) ;
    } // while


    if ( isLess )
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "<=" ) {
    bool isLessEqual = true ;
    while ( inHead -> right -> right -> internal && isLessEqual ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      int main_int = 0, contrast_int = 0 ;
      float main_float = 0, contrast_float = 0 ;
      bool isFirst = true, mainIsFloat = false ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
          stringstream s1 ;
          s1 << arg -> token.lexeme ; 
          if ( isLessEqual && arg -> token.tokenType == FLOAT ) { // deal with float
            if ( isFirst ) {
              s1 >> main_float ;
              isFirst = false ;
              mainIsFloat = true ;
            } // if
  
            else { // do contrast(float)
              s1 >> contrast_float ;
              if ( mainIsFloat )
                isLessEqual = ( main_float <= contrast_float ) ;
              else 
                isLessEqual = ( main_int <= contrast_float ) ;
            } // else 
          } // if
     
          else if ( isLessEqual ) { // deal with int 
            if ( isFirst ) {
              s1 >> main_int ;
              isFirst = false ;
            } // if
  
            else { // do contrast (int) 
              s1 >> contrast_int ;
              if ( mainIsFloat )
                isLessEqual = ( main_float <= contrast_int ) ;
              else 
                isLessEqual = ( main_int <= contrast_int ) ;
            } // else
          } // else if
    
          walk = walk -> right ;
        } // if
    
        else {
          ErrorType error_ ;
          error_.mMessage = "ERROR (<= with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // else
      } while ( walk -> internal ) ;
    } // while


    if ( isLessEqual )
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "=" ) {
    bool isEqual = true ;
    while ( inHead -> right -> right -> internal && isEqual ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      int main_int = 0, contrast_int = 0 ;
      float main_float = 0, contrast_float = 0 ;
      bool isFirst = true, mainIsFloat = false ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( !arg -> internal && ( arg -> token.tokenType == INT || arg -> token.tokenType == FLOAT ) ) {
          stringstream s1 ;
          s1 << arg -> token.lexeme ; 
          if ( isEqual && arg -> token.tokenType == FLOAT ) { // deal with float
            if ( isFirst ) {
              s1 >> main_float ;
              isFirst = false ;
              mainIsFloat = true ;
            } // if
  
            else { // do contrast(float)
              s1 >> contrast_float ;
              if ( mainIsFloat )
                isEqual = ( main_float == contrast_float ) ;
              else 
                isEqual = ( main_int == contrast_float ) ;
            } // else 
          } // if
     
          else if ( isEqual ) { // deal with int 
            if ( isFirst ) {
              s1 >> main_int ;
              isFirst = false ;
            } // if
  
            else { // do contrast (int) 
              s1 >> contrast_int ;
              if ( mainIsFloat )
                isEqual = ( main_float == contrast_int ) ;
              else 
                isEqual = ( main_int == contrast_int ) ;
            } // else
          } // else if
    
          walk = walk -> right ;
        } // if
    
        else {
          ErrorType error_ ;
          error_.mMessage = "ERROR (= with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // else
      } while ( walk -> internal ) ;
    } // while


    if ( isEqual )
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "string-append" ) {
    string resultStr = "\"\"", buf = "" ;
    TokenTreeNodePtr result = new TokenTreeNode ;
    result -> left = NULL ;
    result -> right = NULL ;
    result -> internal = false ;
    result -> token.lexeme = "\"\"" ;
    result -> token.tokenType = STRING ;

    inHead = inHead -> right ;
    do {
      TokenTreeNodePtr arg = EvalExp( inHead -> left, false ) ;
      if ( arg -> internal || arg -> token.tokenType != STRING ) {
        ErrorType error_ ;
        error_.mMessage = "ERROR (string-append with incorrect argument type) : " ;
        error_.mTokenTree = arg ;
        throw error_ ;
      } // if

      resultStr.erase( resultStr.end() - 1 ) ;
      buf = arg -> token.lexeme ;
      buf.erase( buf.begin() ) ;
      resultStr += buf ;
      inHead = inHead -> right ;
    } while ( inHead -> internal ) ;

    result -> token.lexeme = resultStr ;
    return result ;
  } // else if

  else if ( cmd == "string>?" ) { 
    bool isBigger = true ;
    while ( inHead -> right -> right -> internal && isBigger ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      string mainStr = "", cmpStr = "" ;
      bool first = true ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( ( arg -> internal || arg -> token.tokenType != STRING ) ) {
          ErrorType error_ ;
          error_.mMessage = "ERROR (string>? with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // if
  
        if ( isBigger ) {
          if ( first ) {
            mainStr = arg -> token.lexeme ;
            first = false ;
          } // if
    
          else {
            cmpStr = arg -> token.lexeme ;
            isBigger = mainStr > cmpStr ;
          } // else 
        } // if
  
        walk = walk -> right ;
      } while ( walk -> internal ) ;
    } // while

    if ( isBigger )
      return gTTokenPtr ;
    else
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "string<?" ) {
    bool isLess = true ;
    while ( inHead -> right -> right -> internal && isLess ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      string mainStr = "", cmpStr = "" ;
      bool first = true ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( ( arg -> internal || arg -> token.tokenType != STRING ) ) {
          ErrorType error_ ;
          error_.mMessage = "ERROR (string<? with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // if
  
        if ( isLess ) {
          if ( first ) {
            mainStr = arg -> token.lexeme ;
            first = false ;
          } // if
    
          else {
            cmpStr = arg -> token.lexeme ;
            isLess = mainStr < cmpStr ;
          } // else 
        } // if
  
        walk = walk -> right ;
      } while ( walk -> internal ) ;
    } // while

    if ( isLess )
      return gTTokenPtr ;
    else
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "string=?" ) {
    bool isEqual = true ;
    while ( inHead -> right -> right -> internal && isEqual ) {
      inHead = inHead -> right ;
      TokenTreeNodePtr walk = inHead ;
      string mainStr = "", cmpStr = "" ;
      bool first = true ;
      do {
        TokenTreeNodePtr arg = EvalExp( walk -> left, false ) ;
        if ( ( arg -> internal || arg -> token.tokenType != STRING ) ) {
          ErrorType error_ ;
          error_.mMessage = "ERROR (string=? with incorrect argument type) : " ;
          error_.mTokenTree = arg ;
          throw error_ ;
        } // if
  
        if ( isEqual ) {
          if ( first ) {
            mainStr = arg -> token.lexeme ;
            first = false ;
          } // if
    
          else {
            cmpStr = arg -> token.lexeme ;
            isEqual = mainStr == cmpStr ;
          } // else 
        } // if
  
        walk = walk -> right ;
      } while ( walk -> internal ) ;
    } // while

    if ( isEqual )
      return gTTokenPtr ;
    else
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "not" ) {
    TokenTreeNodePtr arg = EvalExp( inHead -> right -> left, false ) ;
    if ( !arg -> internal && arg -> token.tokenType == NIL ) 
      return gTTokenPtr ;

    return gNilTokenPtr ;
  } // else if

  else if ( cmd == "and" ) { 
    bool hasNil = false ;
    TokenTreeNodePtr arg ;
    inHead = inHead -> right ;
    do { 
      arg = EvalExp( inHead -> left, false ) ;
      if ( !arg -> internal && arg -> token.tokenType == NIL )
        hasNil = true ;

      inHead = inHead -> right ;
    } while ( inHead -> internal && !hasNil ) ;

    if ( hasNil ) {
      return gNilTokenPtr ;
    } // if

    return arg ;
  } // else if

  else if ( cmd == "or" ) { 
    TokenTreeNodePtr arg, result = NULL ;
    inHead = inHead -> right ;
    bool hasResult = false ;
    do { 
      arg = EvalExp( inHead -> left, false ) ;
      if ( arg -> internal || arg -> token.tokenType != NIL ) {
        result = arg ;
        hasResult = true ;
      } // if

      inHead = inHead -> right ;
    } while ( inHead -> internal && !hasResult ) ;

    if ( !hasResult ) {
      return gNilTokenPtr ;
    } // if

    return result ;
  } // else if

  else if ( cmd == "eqv?" ) {
    TokenTreeNodePtr arg1, arg2 ;
    arg1 = EvalExp( inHead -> right -> left, false ) ;
    arg2 = EvalExp( inHead -> right -> right -> left, false ) ;
    if ( arg1 == arg2 ) // occupy the same memory
      return gTTokenPtr ;
 
    else if ( !arg1 -> internal && !arg2 -> internal ) {                                   // both are atom
      if ( arg1 -> token.tokenType != STRING && arg2 -> token.tokenType != STRING ) { // expected string
        if ( arg1 -> token.lexeme == arg2 -> token.lexeme ) { // eqv
          return gTTokenPtr ;
        } // if
      } // if
    } // else if

    return gNilTokenPtr ;
  } // else if

  else if ( cmd == "equal?" ) {
    TokenTreeNodePtr arg1, arg2 ;
    arg1 = EvalExp( inHead -> right -> left, false ) ;
    arg2 = EvalExp( inHead -> right -> right -> left, false ) ;
    bool isEqual = Equal_rec( arg1, arg2 ) ;
    if ( isEqual ) 
      return gTTokenPtr ;
    else 
      return gNilTokenPtr ;
  } // else if

  else if ( cmd == "begin" ) {
    TokenTreeNodePtr result ;
    inHead = inHead -> right ;
    while ( inHead -> internal ) {
      result = EvalExp( inHead -> left, false ) ;
      inHead = inHead -> right ;
    } // while

    return result ;
  } // else if

  else if ( cmd == "if" ) {
    bool doIt = true ;
    TokenTreeNodePtr walk = inHead -> right ; // arg1
    TokenTreeNodePtr arg1 = EvalExp( walk -> left, false ) ;
    if ( !arg1 -> internal && arg1 -> token.tokenType == NIL )
      doIt = false ;

    walk = walk -> right ; // arg2 
    if ( doIt ) { // do arg2
      return walk -> left ;
    } // if

    else { // do arg3 
      if ( !walk -> right -> internal ) { // not have arg3, its nil
        ErrorType error_ ;
        error_.mMessage = "ERROR (no return value) : " ;
        error_.mTokenTree = inHead ;
        throw error_ ;
      } // if

      else { // do arg3
        walk = walk -> right ; // arg3
        return walk -> left ;
      } // else
    } // else
  } // else if

  else if ( cmd == "cond" ) { // return to eval() then evaluate the return value of cond 
    bool isLast = false, isElse = false ;
    TokenTreeNodePtr walk, arg, bool_ ;
    walk = inHead -> right ;
    while ( walk -> internal ) {
      if ( !walk -> right -> internal )
        isLast = true ;

      arg = walk -> left ;
      if ( !isLast ) 
        bool_ = EvalExp( arg -> left, false ) ; 

      else { 
        // check if arg is else
        if ( !arg -> left -> internal && arg -> left -> token.lexeme == "else" ) {
          // if it is else,set else
          bool_ = arg -> left ;
          isElse = true ;
        } // if
 
        else { 
          // if it is not else, eval it
          bool_ = EvalExp( arg -> left, false ) ;
        } // else
      } // else

      if ( !bool_ -> internal && bool_ -> token.tokenType == NIL ) {
        ; // do nothing
      } // if

      else if ( isElse ) {
        // find last arg
        arg = arg -> right ;
        while ( arg -> right -> internal ) {
          EvalExp( arg -> left, false ) ;
          arg = arg -> right ;
        } // while

        return EvalExp( arg -> left, false ) ;
      } // else if

      else {
        // find last arg
        while ( arg -> right -> internal ) {
          EvalExp( arg -> left, false ) ;
          arg = arg -> right ;
        } // while

        return EvalExp( arg -> left, false ) ;
      } // else

      walk = walk -> right ;
    } // while  

    // no return value
    ErrorType error_ ;
    error_.mMessage = "ERROR (no return value) : " ;
    error_.mTokenTree = inHead ;
    throw error_ ;
  } // else if

  else if ( cmd == "clean-environment" ) {
    gDefineTable.Clean() ;
    cout << "environment cleaned\n" ;
    return NULL ;
  } // else if

  else {
    cout << "imposible! line:1355" ;
    return NULL ;
  } // else
} // Evaluate()

bool IsList( TokenTreeNodePtr head ) {
  TokenTreeNodePtr walk = head ;
  if ( !head -> internal )
    return true ;

  while ( walk -> right != NULL ) {
    walk = walk -> right ;
  } // while

  if ( walk -> token.tokenType == NIL )
    return true ;

  return false ;
} // IsList()

Token FindFirstArg( TokenTreeNodePtr head, bool &topLevel ) {
  if ( head -> internal ) {
    topLevel = false ;
    return FindFirstArg( head -> left, topLevel ) ;
  } // if

  else 
    return head -> token ;
} // FindFirstArg()

bool CheckArgNum( string sym, TokenTreeNodePtr inTokenTree ) { // define doesn't need to check
  int numOfArg = -2 ; // there has a nil which is not a argument, and sym it self 
  while ( inTokenTree != NULL ) {
    numOfArg++ ;
    inTokenTree = inTokenTree -> right ;
  } // while

  if ( sym == "cons" ) {
    if ( numOfArg == 2 )
      return true ;
  } // if

  else if ( sym == "list" ) {
    if ( numOfArg >= 0 )
      return true ;
  } // else if

  else if ( sym == "quote" ) { // || sym == '\''
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "car" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "cdr" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "atom?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "pair?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "list?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "null?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "integer?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "real?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "number?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "string?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "boolean?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "symbol?" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "+" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "-" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "*" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "/" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if
  
  else if ( sym == "not" ) {
    if ( numOfArg == 1 )
      return true ;
  } // else if

  else if ( sym == "and" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "or" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == ">" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "<" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == ">=" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "<=" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "=" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "string-append" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if
 
  else if ( sym == "string>?" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "string<?" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "string=?" ) {
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "eqv?" ) {
    if ( numOfArg == 2 )
      return true ;
  } // else if

  else if ( sym == "equal?" ) {
    if ( numOfArg == 2 )
      return true ;
  } // else if

  else if ( sym == "begin" ) {
    if ( numOfArg >= 1 )
      return true ;
  } // else if
 
  else if ( sym == "if" ) {
    if ( numOfArg == 2 || numOfArg == 3 )
      return true ;
  } // else if

  else if ( sym == "cond" ) {
    numOfArg++ ; // cond doesn't have sym here
    if ( numOfArg >= 2 )
      return true ;
  } // else if

  else if ( sym == "clean-environment" ) {
    if ( numOfArg == 0 )
      return true ;
  } // else if

  else if ( sym == "exit" ) {
    if ( numOfArg == 0 ) 
      return true ;
  } // else if

  return false ;
} // CheckArgNum()

bool Equal_rec( TokenTreeNodePtr arg1, TokenTreeNodePtr arg2 ) {
  if ( !arg1 -> internal && !arg2 -> internal ) {
    if ( arg1 -> token.lexeme == arg2 -> token.lexeme )
      return true ;

    return false ;
  } // if

  else if ( arg1 -> internal && arg2 -> internal ) { 
    return ( Equal_rec( arg1 -> left, arg2 -> left ) && Equal_rec( arg1 -> right, arg2 -> right ) ) ;
  } // else if

  else 
    return false ;
} // Equal_rec()

bool Define( TokenTreeNodePtr head ) { // error:level of define
  if ( !head -> right -> internal ) // not have argument
    return false ;

  else if ( !head -> right -> right -> internal ) // not have second argument
    return false ;

  else if ( head -> right -> right -> right -> internal ) // have more than two argument
    return false ;

  else {
    TokenTreeNodePtr symbol = head -> right -> left ;
    if ( !symbol -> internal && symbol -> token.tokenType == SYMBOL ) {
      string useless ;
      if ( !gDefineTable.IsInternalFunc( symbol -> token, useless ) ) // can't redefine sym
        return true ;
      else
        return false ;
    } // if

    return false ;
  } // else 
} // Define()

bool Cond( TokenTreeNodePtr head ) {
  if ( !head -> right -> internal )
    return false ;

  TokenTreeNodePtr walk = head -> right ;
  while ( walk -> internal ) {
    if ( walk -> left -> internal ) { // (cond ('at least two argument') )
      if ( CheckArgNum( "cond", walk -> left ) ) {
        TokenTreeNodePtr arg = walk -> left ;
        if ( !IsList( arg ) ) 
          return false ;
      } // if

      else
        return false ;
    } // if

    else {
      return false ;
    } // else

    walk = walk -> right ;
  } // while

  return true ;
} // Cond()

void DefineTable :: BindingSymbol( string symbol, TokenTreeNodePtr tokenTreeHead ) {
  mDefineTable[symbol] = tokenTreeHead ;
} // DefineTable::BindingSymbol()
